---
title: Redis的过期策略以及内存淘汰机制
date: 2019-04-18 09:57:19
tags:
- redis
categories:
- redis
---

**Redis采用的是定期删除+惰性删除策略**，官方文档解释：https://redis.io/commands/expire

# 为什么不用定时删除策略

定时删除，用一个定时器来负责监视key，过期则自动删除，虽然内存及时释放，但是十分消耗CPU资源。

在大并发请求下，CPU要将事件应用在处理请求，而不是删除key，因此没有采用这一策略。

# 定期删除+惰性删除

定期删除，redis默认每隔100ms检查，是否有过期的key，有过期key则删除，需要说明的是，redis不是每隔100ms将所有的key检查一次，而是随机进行检查。

因此，如果只采用定期删除策略，会导致很多key到时间没有删除，于是，惰性删除派上用场了，也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间，那么是否过期了，过期此时就会删除。

若果定期删除没有删除key，然后也没有去请求key，也就是惰性删除也没有发生，这样，redis的内存会越来越高，那么就应该采用内存淘汰机制。

在redis.conf中有一行配置：
```
maxmemory-policy volatile-lru
```
该配置就是配内存淘汰策略的
* noeviction：当内存不足以容纳新写入数据时，新写入操作会报错
* allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（推荐使用）
* allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key
* volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把redis既当缓存，又当持久化存储的时候采用
* volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key
* volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除